// Valid: Comprehensive function overloading demonstration
// Shows all types of valid function overloads in Ciel

// 1. Different number of parameters
int compute(int a) {
    return a * 2;
}

int compute(int a, int b) {
    return a + b;
}

int compute(int a, int b, int c) {
    return a + b + c;
}

// 2. Different parameter types (same count)
int process(int x) {
    return x + 1;
}

int process(float x) {
    return x + 1.0;
}

int process(char x) {
    return x + 1;
}

int process(bool x) {
    if (x) return 1;
    return 0;
}

// 3. Pointer vs non-pointer
int get_value(int x) {
    return x;
}

int get_value(int* ptr) {
    return *ptr;
}

// 4. Different pointer levels
int deref_once(int* p) {
    return *p;
}

int deref_twice(int** pp) {
    return **pp;
}

// 5. Array parameters (treated as pointers)
int sum_array(int arr[5]) {
    return arr[0] + arr[1] + arr[2] + arr[3] + arr[4];
}

int sum_two_arrays(int arr1[3], int arr2[3]) {
    return arr1[0] + arr1[1] + arr1[2] + arr2[0] + arr2[1] + arr2[2];
}

// 6. Different struct types
struct Point2D {
    int x;
    int y;
};

struct Point3D {
    int x;
    int y;
    int z;
};

int get_distance(struct Point2D p) {
    return p.x + p.y;
}

int get_distance(struct Point3D p) {
    return p.x + p.y + p.z;
}

// 7. Struct vs struct pointer
int modify_point(struct Point2D p) {
    return p.x + p.y;
}

int modify_point(struct Point2D* p) {
    p->x = p->x + 1;
    p->y = p->y + 1;
    return p->x + p->y;
}

// 8. Mixed parameter types
int combine(int a, float b) {
    return a + b;
}

int combine(float a, int b) {
    return a + b;
}

int combine(int a, int b, float c) {
    return a + b + c;
}

// 9. Const vs non-const (if supported)
int read_value(int x) {
    return x;
}

// 10. Void parameter list vs empty (no parameters)
int get_constant() {
    return 42;
}

int get_constant_alt() {
    return 100;
}

// 11. Different combinations of signed/unsigned
int add_nums(int a, int b) {
    return a + b;
}

int add_nums(unsigned a, unsigned b) {
    return a + b;
}

// 12. Variadic vs non-variadic (if supported)
// Note: variadic functions may need special syntax

// 13. Return type doesn't matter for overloading (same params = error)
// This would be an error:
// float compute(int a) { return a * 2.0; }  // Error: conflicts with int compute(int)

// 14. Parameter names don't matter for overloading
int multiply(int x, int y) {
    return x * y;
}

int divide(int a, int b) {  // Different name, so this is NOT an overload of multiply
    if (b != 0) return a / b;
    return 0;
}

// 15. Complex nested types
struct Container {
    int value;
};

int extract(struct Container c) {
    return c.value;
}

int extract(struct Container* c) {
    return c->value;
}

int extract(struct Container** c) {
    return (*c)->value;
}

int main() {
    // Test 1: Different number of parameters
    int r1 = compute(5);           // calls compute(int)
    int r2 = compute(5, 10);       // calls compute(int, int)
    int r3 = compute(5, 10, 15);   // calls compute(int, int, int)

    // Test 2: Different parameter types
    int r4 = process(42);          // calls process(int)
    int r5 = process(3.14);        // calls process(float)
    int r6 = process('A');         // calls process(char)
    int r7 = process(true);        // calls process(bool)

    // Test 3: Pointer vs non-pointer
    int val = 100;
    int r8 = get_value(val);       // calls get_value(int)
    int r9 = get_value(&val);      // calls get_value(int*)

    // Test 4: Different pointer levels
    int* ptr = &val;
    int** pptr = &ptr;
    int r10 = deref_once(ptr);     // calls deref_once(int*)
    int r11 = deref_twice(pptr);   // calls deref_twice(int**)

    // Test 5: Array parameters
    int arr[5] = {1, 2, 3, 4, 5};
    int arr1[3] = {10, 20, 30};
    int arr2[3] = {40, 50, 60};
    int r12 = sum_array(arr);
    int r13 = sum_two_arrays(arr1, arr2);

    // Test 6: Different struct types
    struct Point2D p2d;
    p2d.x = 3;
    p2d.y = 4;
    struct Point3D p3d;
    p3d.x = 1;
    p3d.y = 2;
    p3d.z = 3;
    int r14 = get_distance(p2d);   // calls get_distance(Point2D)
    int r15 = get_distance(p3d);   // calls get_distance(Point3D)

    // Test 7: Struct vs struct pointer
    int r16 = modify_point(p2d);   // calls modify_point(Point2D)
    int r17 = modify_point(&p2d);  // calls modify_point(Point2D*)

    // Test 8: Mixed parameter types
    int r18 = combine(5, 3.14);    // calls combine(int, float)
    int r19 = combine(3.14, 5);    // calls combine(float, int)
    int r20 = combine(1, 2, 3.14); // calls combine(int, int, float)

    // Test 9: No parameters
    int r21 = get_constant();
    int r22 = get_constant_alt();

    // Test 10: Signed vs unsigned
    int r23 = add_nums(10, 20);    // calls add_nums(int, int)
    unsigned u1 = 30;
    unsigned u2 = 40;
    int r24 = add_nums(u1, u2);    // calls add_nums(unsigned, unsigned)

    // Test 11: Different operations (not overloads, just different functions)
    int r25 = multiply(6, 7);
    int r26 = divide(20, 4);

    // Test 12: Complex nested types
    struct Container cont;
    cont.value = 999;
    struct Container* cont_ptr = &cont;
    struct Container** cont_pptr = &cont_ptr;
    int r27 = extract(cont);       // calls extract(Container)
    int r28 = extract(cont_ptr);   // calls extract(Container*)
    int r29 = extract(cont_pptr);  // calls extract(Container**)

    return 0;
}
