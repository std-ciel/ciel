// Test name mangling scenarios

// Overloaded functions with different parameter counts
int process(int a) {
    return a;
}

int process(int a, int b) {
    return a + b;
}

int process(int a, int b, int c) {
    return a + b + c;
}

// Overloaded with different parameter types
float calculate(float a) {
    return a;
}

float calculate(int a) {
    return (float)a;
}

float calculate(int a, float b) {
    return a + b;
}

// Overloaded with pointer parameters
int* transform(int* ptr) {
    return ptr;
}

int** transform(int** ptr) {
    return ptr;
}

char* transform(char* str) {
    return str;
}

// Overloaded with struct parameters
struct Point {
    int x;
    int y;
};

struct Point move(struct Point p) {
    return p;
}

struct Point move(struct Point p, int dx, int dy) {
    p.x = dx;
    p.y = dy;
    return p;
}

// Overloaded with mixed types
void execute(int a, char ch) {
    return;
}

void execute(char ch, int a) {
    return;
}

void execute(float f, int a, char ch) {
    return;
}

// Overloaded with unsigned/signed variations
int add(int a, int b) {
    return a + b;
}

unsigned add(unsigned a, unsigned b) {
    return a + b;
}


// Overloaded with various pointer depths
int* allocate(int size) {
    return (int*)0;
}

int** allocate(int rows, int cols) {
    return (int**)0;
}

int*** allocate(int dimx, int dimy, int dimz) {
    return (int***)0;
}

// Class member functions (should have different mangling)
class Calculator {
    public:
        int add(int a, int b);
        float add(float a, float b);
        int multiply(int a, int b);
};

int main() {
    return 0;
}
